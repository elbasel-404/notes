# Caching

## Request Memoization

- While rendering a route, the first time a particular request is called, its result will not be in memory and it'll be a cache MISS.
Therefore, the function will be executed, and the data will be fetched from the external source, and the result will be stored in memory.
Subsequent function calls of the request in the same render pass will be a cache HIT, and the data will be returned from memory without executing the function.
Once the route has been rendered and the rendering pass is complete, memory is "reset" and all request memoization entries are cleared.
- Memoization only applies to the GET method in fetch requests.
- For cases where fetch is not suitable (e.g. some database clients, CMS clients, or GraphQL clients), you can use the React cache function to memoize functions.
- It doesn't apply to fetch requests in Route Handlers as they are not a part of the React component tree.
- The cache lasts the lifetime of a server request until the React component tree has finished rendering.

----

# Data Cache
- In the browser, the cache option of fetch indicates how a request will interact with the browser's HTTP cache, in Next.js, the cache option indicates how a server-side request will interact with the server's Data Cache.
- In development mode, fetch data is reused for Hot Module Replacement (HMR), and caching options are ignored for hard refreshes.



# Types of caching in nexjs

1 - Request Memoization
if two fetch calls have the same inputs they will persist during react's render pass and will be
invaliadated right after rendering is over, this is a react feature and not a nextjs feature
this insures that two fetch calls with the same url and params at two different places (two different files)
will not cause double fetching of data and the result of the first fetch will be used from memory.

2 - Data Cache
this is not enabled by default and has be opted in, data returned by fetch calls can be cached
indefintly, you can use revalidate=numSeconds in single fetch requests or use route segment
config to set revalidate for all fetch calls in that route segment or use revalidateTag/revaliatePath.
This cache is persisted across deployments.

3 - Full route cache
Nextjs builds a cache layer to all route segments (page.tsx) - this only applies to
staticlly rendered routes that don't use any dynamic apis, if a page.tsx or layout.tsx
file uses a dynamic api (like cookies) the whole nested route segment will be opted in
to dynamic server-side rendering and will skip static generation at build time (or at revalidation).
this means that: if you use (import or define) a component that uses a dynamic api in you
root layout.tsx file, the entire app will be opted out of static generation!!!

the steps of full route caching:
    - The RSC is generated by react
    - Next.js uses the RSC/Client Javascript to render html of the page (doesn't include fetched data, caching fetching data is the job of the `Data Cache`)
    - HTML is sent to the browser and an initial non-interactive dom is rendered by the browser without having to wait for the feche calls to complete 
    - Placeholders in the html are present, data is streamecd into them in the background.
    - The fetched data is rendered by the browser
    - The fetched data is duplicated into the browser's cache
    - subsequent navigations to the same route will first hit the browser's cache

this cache is invalidated after deployments and revalidating the data cache
Invalidating the data cache will in turn invalidate the full route cache
If a route segment has a fetch call that is not cached, this will opt out the route segment from full route cache as well.
Which means in order to staticly render a page at build time all fetch calls within it needs to be cached by settings { cache: "force-cache" }.

Using `export const dynamic = "force-dynamic" or `export const revalidate = 0` from a route segment will also opt it out from static generation.
Using router.refresh() will invalidate the client-side router cache as well.

you can use generateStaticParams inside dynamic route segments to prerender pages otherwise the page will be rendered at request time.

You can use prefetch={true} on <Link /> components to prefetch the link when it comes into the viewport and to store a client-side cache of the page itself (5 mins by default). This is the default behavior for static pages.
a Hard referesh will always invalidate the cient-side cache.

You can use `staleTime` config to enable client-side caching for all pages, setting caching behvaior for both dynamic and static pages seperatly.


Full Route Cache invalidation does not affect data cache.

Revalidating the Data Cache in a Route Handler will not immediately invalidate the Router Cache as the Route Handler isn't tied to a specific route. This means Router Cache will continue to serve the previous payload until a hard refresh, or the automatic invalidation period has elapsed.
